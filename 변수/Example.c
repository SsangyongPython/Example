#include <stdio.h>

int main()
{
    /* 변수란 뭘까? */

    char var_1 = 1; // 1바이트 변수에 1저장
    short var_2 = 1; // 2바이트 변수에 1저장
    int var_4 = 1; // 4바이트 변수에 1저장

    var_1 = 16; // 변수에 값을 넣을 수 있다
    printf("var_1의 값 : %d\n", var_1); // 포맷스트링을 이용해 변수의 값을 출력

    /* 표준 입력 */

    printf("정수를 하나 입력 : ");   scanf("%d", &var_4); // 사용자로부터 입력값을 받는다
    printf("%d를(을) 입력하셨습니다\n\n", var_4);

    /* 사칙연산 */

    var_4 = 1 + 8 * 2 / 4;
    printf("1 + 8 * 2 / 4 = %d\n", var_4); // 5출력
    var_4 = ((1 + 8) * 2) / 4;
    printf("((1 + 8) * 2) / 4 = %d\n\n", var_4); // 4출력

    /* 음수 표현 */

    var_1 = 255;
    printf("var_1 = %d\n", var_1); // -1출력
    unsigned char u_var_1 = var_1;
    printf("하지만 unsigned var_1의 값은 %d\n", u_var_1); // 255출력

    var_4 = 256*256*256*256 - 1; // 2^32 - 1
    printf("***** 예외 *****\n");
    printf("var_4 = %d\n", var_4); // -1출력
    unsigned int u_var_4 = var_4;
    printf("unsigned var_4 = %d\n\n", u_var_4); // -1출력
    /*
     * u_var_4는 코드상에서 양수로 판단되긴 하지만
     * printf에 넘겨줄 때 인자값은 char던 short던 무조건 4바이트로 크기를 맞춰서 들어가기 때문에
     * 이 경우에서 MSB는 signed던 unsigned던 무조건 1이된다
     *
     * 크기를 늘릴때는 해당 값의 MSB를 써서 빈 공간을 채우게 되는데,
     * 예를 들어 signed char로 0xFF라는 값을 넘겨주면 인자에 들어갈 때 크기를 4바이트로 늘려서
     * 0xFFFFFFFF로 들어간다. 그런데 0x7F를 넘기면 0x0000007F로 들어간다.
     * 즉 signed 일 때는 크기를 늘렸을때 빈 공간을 MSB로 채운다는 것이다.
     *
     * 이번엔 signed가 아니라 unsigned를 한번 생각해보면
     * unsigned는 빈 공간을 MSB로 채우는게 아니라 무조건 0으로 채운다.
     * 예를 들어 unsigned char로 0xFF라는 값을 넘긴다고 하면
     * 이 값을 4바이트로 늘렸을때 빈 공간을 0으로 채워서 0x000000FF로 넘긴다.
     *
     * 하지만 4바이트를 넘기는 경우를 생각해보면 이 경우는 크기를 늘릴 필요가 없다.
     * signed int로 0xFFFFFFFF나 unsigned int로 0xFFFFFFFF나 인자로 들어갈 땐
     * 똑같이 0xFFFFFFFF로 들어가고, printf는(좀 더 정확하게 말하면 %d는) 들어온 4바이트 인자값의 MSB를 보고
     * 단순하게 0이면 양수로 출력, 1이면 음수로 출력하기 때문에 unsigned여도 음수로 출력하게 되는것이다.
     *
     * 이 문제를 해결하기 위한 조치로 %d대신 %u를 쓰는 방법이 있는데
     * %u는 MSB를 아예 안보고 무조건 양수로만 출력하기 때문에 저런 상황이라면 유용하게 사용할 수 있다.
     * 근데 변수의 값이 아니라 크기를 늘려 들어온 4바이트 인자값을 양수로 취급하는거라 상황에 따라 적절하게 써야한다.
     * 예를 들어 %u를 이런식으로 쓴다고 치면 :
     *
     * char d = 0xFF;
     * printf("%u", d);
     *
     * 적절한 결과를 얻지 못할것이다.
     * 원래는 이 내용도 동아리 강의때 다루려고 했는데 내용이 많이 복잡하고 시간도 부족한 것 같아서 생략했다.
     * 몇명이나 읽을지 모르겠지만 궁금한 친구들도 있을것 같아서 설명을 적어놓았다.
     */
    return 0;
}
